---
layout: post
category: JAVA
title: java泛型
---
Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

## 泛型方法
- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。
- 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
- 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
- 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）

```java
public class GenericMethodTest
{
   // 泛型方法 printArray                         
   public static < E > void printArray( E[] inputArray )
   {
      // 输出数组元素            
         for ( E element : inputArray ){        
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
 
    public static void main( String args[] )
    {
        // 创建不同类型数组： Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
 
        System.out.println( "整型数组元素为:" );
        printArray( intArray  ); // 传递一个整型数组
 
        System.out.println( "\n双精度型数组元素为:" );
        printArray( doubleArray ); // 传递一个双精度型数组
 
        System.out.println( "\n字符型数组元素为:" );
        printArray( charArray ); // 传递一个字符型数组
    } 
}
```

## 泛型类
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。

```java
public class Box<T> {
   
  private T t;
 
  public void add(T t) {
    this.t = t;
  }
 
  public T get() {
    return t;
  }
 
  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    Box<String> stringBox = new Box<String>();
 
    integerBox.add(new Integer(10));
    stringBox.add(new String("菜鸟教程"));
 
    System.out.printf("整型值为 :%d\n\n", integerBox.get());
    System.out.printf("字符串为 :%s\n", stringBox.get());
  }
}
```

## 类型通配符
类型通配符一般是使用?代替具体的类型参数。例如 ```List<?>``` 在逻辑上是```List<String>```,```List<Integer>``` 等所有```List<具体类型实参>```的父类

然而```List<Integer>```不是```List<Object>```子类

```java
public class GenericTest {
     
    public static void main(String[] args) {
        List<String> name = new ArrayList<String>();
        List<Integer> age = new ArrayList<Integer>();
        List<Number> number = new ArrayList<Number>();
        
        name.add("icon");
        age.add(18);
        number.add(314);
 
        getData(name);
        getData(age);
        getData(number);
       
   }
 
   public static void getData(List<?> data) {
      System.out.println("data :" + data.get(0));
   }
}
```

## <? extends T>和<? super T>的区别

前者表示该通配符所代表的类型是T类型的子类。

后者表示该通配符所代表的类型是T类型的父类。

```java
   public static void getUperNumber(List<? extends Number> data) {
          System.out.println("data :" + data.get(0));
       }
```

## 类型擦除
[Java类型擦除机制](https://www.cnblogs.com/chenpi/p/5508177.html)

记住：Java的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息。

看这段代码

```java
package simplejava;

import java.util.ArrayList;

public class Q29 {
    public static void main(String[] args) {
        ArrayList<String> al = new ArrayList<String>();
        al.add("a");
        al.add("b");
        accept(al);
    }

    public static void accept(ArrayList<Object> al) {
        for (Object o : al)
            System.out.println(o);
    }

}
```

以上代码看起来是没问题的，因为String是Object的子类。然而，这并不会工作，编译不会通过，并提示如下错误：
```
The method accept(ArrayList<Object>) in the type Q29 is not applicable for the arguments (ArrayList<String>)
```

在编译之后，```List<Object>```和```List<String>```将变成List，Object和String类型信息对于JVM来说是不可见的。在编译阶段，编译器发现它们不一致，因此给出了一个编译错误。也就是说编译阶段就检查出来不一样了，但是编译后就变的一样了，因为类型擦除。

永远记住，泛型是一个编译时的概念。在这个例子中，由于我们不知道```？```，我们不能添加任何元素到al集合。如果想要添加的话，可以使用通配符。

现在，我们知道了```ArrayList <String >```并不是```ArrayList <Object >```的子类型，不过，你需要知道如果两个泛型类型有相同的参数，它们的继承关系是依据其类型。如```ArrayList<String>```是```Collecton<String>```的子类型。

然而，数组却不同，它们在运行期间知道每个元素的类型且强制它们的元素为该类型，这叫reification。举个例子，Object[] objArray是String[] strArr的超类型。如果你尝试往存储整型的数组添加字符串对象，将会在运行期间得到一个ArrayStoreException异常。

因此：不能创建实际的持有泛型的数组对象，数组必须知道它们所持有的确切类型。


### 一，数组的协变性(covariant array type)及集合的非协变性
设有Circle类和Square类继承自Shape类。

关于数组的协变性，看代码：
```java
public static double totalArea(Shape[] arr){
        double total = 0;
        for (Shape shape : arr) {
            if(shape != null)
                total += shape.area();
        }
        return total;
    }
```

如果给 totalArray(Shape[] arr) 传递一个Circle[] 类型的数组，这是可以的，编译通过，也能正常运行。也就是说：Circle[] IS-A Shape[]

关于集合的协变性，看代码：
```java
public static double totalArea(Collection<Shape> arr){
        double total = 0;
        for (Shape shape : arr) {
            if(shape != null)
                total += shape.area();
        }
        return total;
    }
```

给totalArea(Collection<Shape> arr)传递一个 ```Collection<Circle>```类型的集合，这是不可以的。编译器就会报如下的错误：

```The method totalArea(Collection<Shape>) in the type Demo is not applicable for the arguments (Collection<Circle>)```

也就是说，形参是```List<Object>```，你无法传入```List<Object>```,```List<Integer>```,```ArrayList<Object>```等

### 二，如果解决集合的非协变性带来的不灵活？
```java
public static double totalArea(Collection<? extends Shape> arr){
        double total = 0;
        for (Shape shape : arr) {
            if(shape != null)
                total += shape.area();
        }
        return total;
    }
```

这样，就可以给totalArea(Collection<? extends Shape> arr)

传递Collection<Circle>、Collection<Square>、Collection<Shape>类型的参数了。

假如B继承A

```java
List<?>与List一样
List<Object>可以赋值给List
//假如B继承A
List<B>可以赋值给List<? extends A>
List<? extends B>也可以赋值给List<? extends A>
```

### 三，泛型的类型擦除及类型擦除带来的ClassCastException异常
JAVA的泛型只存在于编译层，到了运行时，是看不到泛型的。

还是拿数组来做对比：

```java
 String[] str = new String[10];
 Object[] obj = str;//向上转型
 
 //Exception in thread "main" java.lang.ArrayStoreException: java.lang.Integer
 obj[0] = new Integer(2);
```

第5行代码在运行时会抛第4行中表示的异常。

再来看泛型：

```java
ArrayList<Integer> intList = new ArrayList<Integer>();
        intList.add(2);
        Object obj = intList;
        
        //Type safety: Unchecked cast from Object to ArrayList<String>
        ArrayList<String> strList = (ArrayList<String>)obj;
        
        //Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
        String str = strList.get(0);
        str.trim();//do something with str
```

编译器会对第6行提示第5行所示的警告。程序运行到第9行时抛出ClassCastException异常。因为ArrayList存储的本质上是一个Integer。

现在分析下第6行代码：

obj是Object类型的引用，strList是一个ArrayList<String>类型的引用，因此，向下转型时编译器给出了警告，在运行时，由于类型擦除，相当于

ArrayList strList = (ArrayList)obj;
因此，代码运行到第6行也能通过。

对于第9行代码：

strList但是一个ArrayList<String>类型的引用，当然可以调用 ArrayList的get方法。因此，编译时没问题。在运行时，

由于，String str = strList.get(0);会编译成String str = (String)strList.get(0);

而strList.get(0)得到 的是一个Integer对象，然后把它赋值给 String str，由于Integer IS-NOT-A String。故抛出ClassCastException。

### 四，为什么不支持泛型数组
现在我们假设在 Java 中可以创建泛型数组，看看可能会发生什么情况：

```java
// 假设可以创建泛型数组
List<String>[] stringLists = new ArrayList<String>[1];
List<Integer> intList = Arrays.asList(42);
// 泛型擦除，List 继承自 Object，所以可以如此赋值
// 在数组中，子类数组 是 父类数组 的子类，Object[] o = new ArrayList[1];
Object[] objects = stringLists;
// 同理，泛型擦除后，List 类型变量赋值给 Object 类型变量
// 但此时出现问题了，**** List<Integer> 实例添加到了声明为 List<String>[] 类型的数组中了 ******
objects[0] = intList;
String s = stringLists[0].get(0);
```
在运行时，类型是擦除的，运行时系统无法对数组中存储的类型做检查

由于泛型擦除，结果就是泛型的检查作用失效，可以将 List<Integer> 类型的值添加到 List<String>[] 类型的数组中。

而这类问题在编译时无法发现，只能在运行时出现问题

所以如果禁止创建泛型数组，就可以避免此类问题

### 解决方案

#### 泛型数组包装器
用ArrayList收集泛型数组对象的对象元素，如ArrayList<T>、ArrayList<Pair<String>>

将获得数组的行为，以及由泛型提供的编译期的类型安全

#### 反射
通过反射在运行时构出实际类型为type[]的对象数组，避免了类型擦除，从而转换成功，无ClassCastException

```java
import java.lang.reflect.*; 

public class GenericArrayWithTypeToken<T> {
    private T[] array;
    @SuppressWarning("unchecked")
    public GenericArrayWithTypeToken(Class<T> type, int sz) {
        array = (T[]) Array.newInstance(type, sz);//通过反射在运行时构出实际类型为type[]的对象数组，避免了类型擦除，从而转换成功，无ClassCastException
    }
    public void put(int index, T item){
        array[index] = item;
    }
    public T get(int index) { return array[index]; }
    public T[] rep() { return array; }  //能成功返回了~
    public static void main(String[] args) {
        GenericArrayWithTypeToken<Integer> gawtt = new GenericArrayWithTypeToken<>(Integer.class, 10);
        Integer[] ia = gawtt.rep(); //能成功返回了！
    }
}
```

#### 通配符
[The Java™ Tutorials: Generics](https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html)
给出的解决方案如下：

```java
// OK, array of unbounded wildcard type.
List<?>[] lsa = new List<?>[10];
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
// Correct.
oa[1] = li;
// Run time error, but cast is explicit.
String s = (String) lsa[1].get(0);
```

一定要用List<?>或者List后面那块，前面得无所谓了

比如
```java
 List<Integer>[] graphic = new List[numCourses];
for (int i = 0; i < numCourses; i++) {
    graphic[i] = new ArrayList<>();
}
```