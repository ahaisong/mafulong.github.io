---
layout: post
category: JAVA
title: Java类型擦除机制
---

[Java类型擦除机制](https://www.cnblogs.com/chenpi/p/5508177.html)

记住：Java的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息。

在编译之后，List<Object>和List<String>将变成List，Object和String类型信息对于JVM来说是不可见的。在编译阶段，编译器发现它们不一致，因此给出了一个编译错误。

永远记住，泛型是一个编译时的概念。在这个例子中，由于我们不知道？，我们不能添加任何元素到al集合。如果想要添加的话，可以使用通配符。

现在，我们知道了ArrayList <String >并不是ArrayList <Object >的子类型，不过，你需要知道如果两个泛型类型有相同的参数，它们的继承关系是依据其类型。如ArrayList<String>是Collecton<String>的子类型。

然而，数组却不同，它们在运行期间知道每个元素的类型且强制它们的元素为该类型，这叫reification。举个例子，Object[] objArray是String[] strArr的超类型。如果你尝试往存储整型的数组添加字符串对象，将会在运行期间得到一个ArrayStoreException异常。

记住：不能创建实际的持有泛型的数组对象，数组必须知道它们所持有的确切类型。