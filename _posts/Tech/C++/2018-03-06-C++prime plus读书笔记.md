---
layout: post
category: C语言
title: C++ primer plus读书笔记
---

指针常量： int * const p

常量指针:  const int*p / int const *p

数组指针： int (*p)[]=&x;
    (*p)[i]

函数指针 int (*p)(int a);
    调用：(*p)(3)或者p(3)

*p++指*p,p++  返回的是*p，但是p++

++，--都是映射存于寄存器中

存的谁地址，就以谁的长度为偏移单位，eg *(a+1)

函数指针：
```
    void test(){};
    typedef void(func)();
    typedef void(*func_ptr_c)();
    func *f=test;
    func_ptr_c p=test;
    f();
    p();
```

指针类型强制转换
    (int*)&p把p转换int型指针

- 若将成员函数放到头文件中，则所有的成员函数都作为内联函数处理
？？？这有个问题，不是成员函数都是内联函数么？？
- 可以声明void类型的指针, 这表示一种通用性指针，任何类型的指针值都可以赋值给void*类型的指针变量
- 不能建立void的引用，不能建立引用的数组（数组是地址，不是占有存储空间的变量），不能建立引用的引用（引用不是一种数据类型），可以将引用的地址赋给一个指针
- 内联成员函数定义方式有两种
1. 隐式声明：直接定义到类内部
2. 显式声明：用inline声明
- 为什么使用初始化列表？某些类型如const类型和引用类型是不允许在构造函数中用赋值语句直接赋值的，因此，只能用成员初始化列表进行初始化
- 列表初始化是按照在类中的成员声明顺序来的，一定要注意
- 当基类中声明虚函数，子类同名函数会自动加上虚函数修饰。
- 多态有个严重问题，(想去借助父类指针去销毁子类对象的时候去不能去销毁子类对象)，因此要引入虚析构函数
- 静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。
- 内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。
- static变量与方法不能被继承，只能被共享。
- 重载++，即```classname operator++()```的时候，为了区分是前置还是后置++，规定是后置自增运算符时，要带一个伪参数，即```classname operator++(int)```, 在友元函数中就是```friend classname classname::operator++(classname &,int)```
