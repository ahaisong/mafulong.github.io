---
layout: post
category: 算法知识
title: 快速排序
---

## 快速排序

以l==r作为出栈入口


![](https://i.imgur.com/DmVqDeO.png)

```c++

int partition(vector<int> &v, int left, int right) {
	int p = v[left];
	while (left < right) {
		while (left<right&&v[right]>p) right--;
		if (left < right) {
			v[left] = v[right];
			left++;
		}
		while (left < right&&v[left] < p) left++;
		if (left < right) {
			v[right] = v[left];
			right--;
		}
	}
	v[left] = p;
	return left;
}
void quicksort1(vector<int> &v, int left, int right) {
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << endl;

	if (left < right) {
		int r = partition(v, left,right);
		quicksort1(v, left, r-1);
		quicksort1(v, r + 1, right);
	}
	return;

}
void quicksort(vector<int> &v) {
	quicksort1(v, 0, v.size() - 1);
}
int main() {
	//cout << fibonacci2(8) << endl;
	//cout << fibonacci1(8) << endl;
	//vector<int> v;
	//mergesort(v);
	//for (int i = 0; i < v.size(); i++) {
	//	cout << v[i] << endl;
	//}
	vector<int> v = { 2,3,6,9,1,4,5 };
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << endl;

	//cout << partition(v,0,v.size()-1) << endl;
	quicksort(v);
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}

}

```

```c++
int partition(vector<int> &v, int left, int right) {
	int p = v[left];
	while (left < right) {
		while (left<right&&v[right]>p) right--;
		if(left<right) v[left++] = v[right];
		while (left < right&&v[left] < p) left++;
		if (left < right) v[right--] = v[left];
	}
	v[left] = p;
	return left;
}
int quicksort(vector<int>&v, int left, int right) {
	if (left < right) {
		int r = partition(v, left, right);
		quicksort(v, left, r - 1);
		quicksort(v, r + 1, right);
	}
	return 0;
}
```

## 算法改进
（一）切换到插入排序

因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。

（二）三数取中

最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。

（三）三向切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序。
```c++
public class ThreeWayQuickSort<T extends Comparable<T>> extends QuickSort<T> {
    @Override
    protected void sort(T[] nums, int l, int h) {
        if (h <= l)
            return;
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i <= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp < 0)
                swap(nums, lt++, i++);
            else if (cmp > 0)
                swap(nums, i, gt--);
            else
                i++;
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}
```

