---
layout: post
category: JAVA
title: 二叉树java实现
---

## 节点
```java
    static class Tree{
        Tree left,right;
        int data;
        Tree(int data){
            this.data=data;
        }
    }
```

## 遍历
```java
    static void visitLVR(Tree root){
        if(root!=null){
            visitLVR(root.left);
            System.out.print(root.data+" ");
            visitLVR(root.right);
        }
    }
    static void visitVLR(Tree root){
        if(root!=null){
            System.out.print(root.data+" ");
            visitVLR(root.left);
            visitVLR(root.right);
        }
    }
    static void visitLRV(Tree root){
        if(root!=null){
            visitLRV(root.left);
            visitLRV(root.right);
            System.out.print(root.data+" ");
        }
    }
    static void visitlevel(Tree root){
        ArrayDeque<Tree> arrayDeque=new ArrayDeque<>();
        arrayDeque.add(root);
        int last=1;
        while (arrayDeque.size()>0){
            Tree t=arrayDeque.pollFirst();
            System.out.print(t.data+" ");
            if(t.left!=null)
                arrayDeque.add(t.left);
            if(t.right!=null)
                arrayDeque.add(t.right);
        }
    }
```

## 创建二叉树
```java

    static void visitLVR(Tree root){
        if(root!=null){
            visitLVR(root.left);
            System.out.print(root.data+" ");
            visitLVR(root.right);
        }
    }
    static void visitVLR(Tree root){
        if(root!=null){
            System.out.print(root.data+" ");
            visitVLR(root.left);
            visitVLR(root.right);
        }
    }
    static void visitLRV(Tree root){
        if(root!=null){
            visitLRV(root.left);
            visitLRV(root.right);
            System.out.print(root.data+" ");
        }
    }
    static int index=0;
    /**
     * 先序创建二叉树
     * @param data
     * @return
     */
    static Tree createTree1(int[] data){
        Tree root=null;
        if(index>=0&&index<data.length&&data[index]!='*'){
            root=new Tree(data[index]);
            index++;
            root.left=createTree1(data);
            index++;
            root.right=createTree1(data);
        }
        return root;
    }

    /**
     * 按后序创建二叉树
     * @param data
     * @return
     */
    static Tree createTree2(int[] data){
        Tree root=null;
        if(index>=0&&data[index]!='*'){
            root=new Tree(data[index]);
            index--;
            root.left=createTree2(data);
            index--;
            root.right=createTree2(data);
        }
        return root;
    }

    /**
     * 按层次遍历，记住起始不能是0了，2*0=0，所以要加1个，1开始
     * @param data
     * @param index1
     * @return
     */
    static Tree createTree3(int[] data,int index1){
        Tree root=null;
        if(index1<data.length&&data[index1]!='*'){
            root=new Tree(data[index1]);
            root.left=createTree3(data,2*index1);
            root.right=createTree3(data,2*index1+1);
        }
        return root;
    }
    public static void main(String[] args){
        int[] data=new int[]{1,2,'*',3,'*','*',4,'*','*'};
        data=new int[]{'*','*','*',3,2,'*','*',4,1};
        data=new int[]{'*',1,2,4,'*',3,'*','*','*','*'};

        Tree root=createTree3(data,1);
        visitLRV(root);
        System.out.println();
        visitVLR(root);
        System.out.println();
    }
```

## 计算深度
```java
    /**
     * 计算深度
     * @param root
     * @return
     */
    static int depth(Tree root){
        if(root==null)
            return 0;
        int left=depth(root.left);
        int right=depth(root.right);
        return max(left,right)+1;
    }
```

## 计算宽度
```java
    /**
     * 计算宽度
     * @param root
     * @return
     */
    static int width(Tree root){
        if(root==null)
            return 0;
        ArrayDeque<Tree> arrayDeque=new ArrayDeque<>();
        arrayDeque.add(root);
        int last=1;
        int maxWidth=1;
        while(!arrayDeque.isEmpty()){
            while(last-->0){
                Tree t=arrayDeque.pollFirst();
                if(t.left!=null){
                    arrayDeque.add(t.left);
                }
                if(t.right!=null){
                    arrayDeque.add(t.right);
                }
            }
            last=arrayDeque.size();
            maxWidth=max(maxWidth,last);
        }
        return maxWidth;
    }
```

## 查找x值
```java
    /**
     * 二叉树查找x值
     * @param root
     * @param key
     * @return
     */
    static Tree find(Tree root,int key){
        if(root==null){
            return null;
        }
        if(root.data==key){
            return root;
        }else{
            Tree t=find(root.left,key);
            if(t!=null){
                return t;
            }else{
                return find(root.right,key);
            }
        }
    }
```
## 后序遍历非递归
```java
    /**
     * 后序遍历非递归实现
     * @param root
     */
    static void postOrder(Tree root){
        ArrayDeque<Tree> arrayDeque=new ArrayDeque<>();
        arrayDeque.push(root);
        Tree pre=null;
        Tree cur=null;
        while(!arrayDeque.isEmpty()){
            cur=arrayDeque.peekFirst();
            if((cur.left==null&&cur.right==null)
                    ||(pre!=null&&(pre==cur.left||pre==cur.right))){
                System.out.print(cur.data+" ");
                arrayDeque.pop();
                pre=cur;
            }else{
                if(cur.right!=null){
                    arrayDeque.push(cur.right);
                }
                if(cur.left!=null){
                    arrayDeque.push(cur.left);
                }
            }
        }
    }
```