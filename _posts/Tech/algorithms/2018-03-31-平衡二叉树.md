---
layout: post
category: 算法知识
title: 平衡二叉树
---

## 平衡二叉树
### 定义
平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

平衡因子(bf)：结点的左子树的深度减去右子树的深度，那么显然-1<=bf<=1

失去平衡的最小子树是指以离插入结点最近，且平衡因子绝对值大于1的结点作为根的子树。假设用A表示失去平衡的最小子树的根结点，则调整该子树的操作可归纳为下列四种情况。

当对一颗AVL树进行插入操作，可能会导致AVL树不平衡，此时，我们就需要做平衡处理，假设重新平衡的节点为Q，则不平衡会下列四种情况，并做出调整

在Q的左孩子的左子树插入 （LL）

在Q的左孩子的右子树插入 （LR）

在Q的右孩子的左子树插入  （RL）

在Q的右孩子的右子树插入  （RR）


#### 参考文章
[文章链接](https://blog.csdn.net/lpp0900320123/article/details/39367451#t4)

### 平衡处理

#### 左平衡
所谓左平衡处理，就是某一根结点的左子树比右子树过高，从而失去了平衡。在节点的左子树进行插入操作使此节点失去平衡，需要左平衡处理。

#### 右平衡
类似左平衡处理，所谓右平衡处理，就是某一根结点的右子树比左子树过高，从而失去了平衡。

#### LL
![](https://i.imgur.com/lZEiG6n.png)

思路：先把B的右子树变为A的左子树，在把A作为B的右子树

#### RR
![](https://i.imgur.com/lj3zIun.png)

思路：先把C的左子树作为A的右子树，在把A作为C的左子树。

#### LR
![](https://i.imgur.com/Fu6ROyB.png)

先将A结点的左孩子B的右子树的根结点D向左上旋转提升到B结点的位置，然后再把该D结点向右上旋转提升到A结点的位置。即先使之成为LL型，再按LL型处理。

如图中所示，先将圈圈的部分进行逆时针旋转（RR旋转），使之转换为LL型，再进行LL旋转；（双旋转）

#### RL
![](https://i.imgur.com/lbZGKBG.png)

如图中所示，先将圈圈的部分进行顺时针旋转（LL旋转），使之转换为RR型，再进行RR旋转；（双旋转）

### 代码
```c++
#include<algorithm>
#include<iostream>
#include<stdio.h>
#include<string>
#include<vector>
#include<queue>
using namespace std;


struct t
{
	int data;
	t *left, *right;
	int height;
	t() :data(0), left(NULL), right(NULL), height(0) {

	}
	t(int data1) :data(data1), left(NULL), right(NULL), height(0) {
	}
};
int nodeheight(t *node) {
	return node == NULL ? -1 : node->height;
}
int updateHeight(t *node) {
	//cout << "new height  " << node->data << "  " << max(nodeheight(node->left), nodeheight(node->right)) + 1 << endl;;
	return max(nodeheight(node->left), nodeheight(node->right)) + 1;
}
void LL(t *&node) {
	if (node) {
		t *p = node->left;
		node->left = p->right;
		updateHeight(node);
		p->right = node;
		updateHeight(p);
		node = p;
	}

}
void RR(t *&node) {
	if (node) {
		t *p = node->right;
		node->right = p->left;
		updateHeight(node);
		p->left = node;
		updateHeight(p);
		node = p;
	}
}
void LR(t *&node) {
	if (node) {
		RR(node->left);
		LL(node);
	}
}
void RL(t *&node) {
	if (node) {
		LL(node->right);
		RR(node);
	}
}
void LeftBalance(t *&node) {
	cout << "leftBalance  " << node->data << endl;
	t *p = node->left;
	if (nodeheight(p->left) < nodeheight(p->right)) {
		LR(node);
	}
	else {
		LL(node);
	}
}
void RightBalance(t *&node) {

	//cout << "rightBalance   " << node->data << endl;
	t *p = node->right;
	if (nodeheight(p->left) > nodeheight(p->right)) {
		RL(node);
	}
	else {
		RR(node);
	}
}
void insertNode(t *&node,int data) {

	if (!node) {
		node = new t(data);
	}
	else if (data < node->data) {
		//cout << node->data <<" left: "<<data<< endl;
		insertNode(node->left, data);
		if (nodeheight(node->left) - nodeheight(node->right) == 2) {
			LeftBalance(node);
		}
	}
	else if (data > node->data) {
		//cout << node->data << " right: " << data << endl;

		insertNode(node->right, data);
		if (nodeheight(node->left) - nodeheight(node->right) == -2) {
			RightBalance(node);
		}
	}
	else
		cout<<node->data << "重复插入" << endl;
	node->height=updateHeight(node);
}
void deleteNode(t *&node,int data) {
	if (!node) {
		return;
	}
	if (data > node->data) {
		deleteNode(node->right, data);
		if (nodeheight(node->left) - nodeheight(node->right) == 2) {
			LeftBalance(node);
		}
	}
	else if (data < node->data) {
		deleteNode(node->left, data);
		if (nodeheight(node->right) - nodeheight(node->left) == 2) {
			RightBalance(node);
		}
	}
	else {
		if (!node->left) {
			t *p = node;
			node = node->right;
			delete p;
		}
		else if (!node->right) {
			t *p = node;
			node = node->left;
			delete p;
		}
		else {
			t *p = node->left;
			while (p->right) {
				p = p->right;
			}
			node->data = p->data;
			deleteNode(node->left, p->data);
		}
	}
}
t* createTree(vector<int> v) {
	t *root = NULL;
	for (int i = 0; i < v.size(); i++) {
		insertNode(root,v[i]);
	}
	return root;
}
void visitlvr(t *root) {
	if (root != NULL) {
		visitlvr(root->left);
		cout << root->data << " ";
		visitlvr(root->right);
	}
}
void visitvlr(t *root) {
	if (root != NULL) {
		cout << root->data << " ";
		visitvlr(root->left);
		visitvlr(root->right);
	}
}
void visitlrv(t *root) {
	if (root != NULL) {
		visitlrv(root->left);
		visitlrv(root->right);
		cout << root->data << " ";
	}
}
void visitTree(t *tree) {
	visitlvr(tree);
	cout << endl;
	visitvlr(tree);
	cout << endl;
	visitlrv(tree);
	cout << endl;
}
int main() {
	freopen("D:/in.txt", "r", stdin);

	vector<int> v;
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int a;
		cin >> a;
		v.push_back(a);
	}
	t *tree = createTree(v);
	visitTree(tree);
	deleteNode(tree, 7);
	visitTree(tree);
	//visitTree(tree);
	return 0;
}
```

## 2-3查找树

#### 定义
一棵2-3查找树或为一颗空树，或由以下节点组成：

- 2-节点：含有一个键和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点。
- 3-节点：含有两个键和三条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点。

#### 1. 插入操作
插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上。但是 2-3 查找树如果也这么做的话，那么就会破坏了平衡性。它是将新节点插入到叶子节点上。

根据叶子节点的类型不同，有不同的处理方式：

- 如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可。

![](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/7f38a583-2f2e-4738-97af-510e6fb403a7.png)

- 如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。

![](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/ef280699-da36-4b38-9735-9b048a3c7fe0.png)

#### 2. 性质
2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。

2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。

2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。

## 红黑树

#### 第一种

第一种红黑树是2-3查找树演变而来

2-3 查找树需要用到 2- 节点和 3- 节点，红黑树使用红链接来实现 3- 节点。指向一个节点的链接颜色如果为红色，那么这个节点和上层节点表示的是一个 3- 节点，而黑色则是普通链接。

#### 第二种
第二种红黑树是2-3-4查找树演变而来，也就是符合下面5个特点

- 性质1. 节点是红色或黑色。
- 性质2. 根节点是黑色。
- 性质3 每个叶节点（NIL节点，空节点）是黑色的。
- 性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
