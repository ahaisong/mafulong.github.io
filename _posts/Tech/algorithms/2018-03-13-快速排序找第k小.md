---
layout: post
category: 算法知识
title: 快速排序找第k小
---

## 自己写的
改造于快排，记得是if(left<right)

```c++
#include<iostream>
#include<vector>
using namespace std;

int partition(vector<int> &v, int left, int right) {
	int p = v[left];
	while (left < right) {
		while (left<right&&v[right]>p) right--;
		if (left < right) {
			v[left] = v[right];
			left++;
		}
		while (left < right&&v[left] < p) left++;
		if (left < right) {
			v[right] = v[left];
			right--;
		}
	}
	v[left] = p;
	return left;
}
//第k小
int k, res;

void quicksort1(vector<int> &v, int left, int right) {
	//for (int i = 0; i < v.size(); i++) {
	//	cout << " " << v[i];
	//}
	//cout << endl;

	//if (left < right) {
	//	int r = partition(v, left, right);
	//	quicksort1(v, left, r - 1);
	//	quicksort1(v, r + 1, right);
	//}

	//mfl modefied
	//求第k小
	if (left <= right) {
		int r = partition(v, left, right);
		cout << "KKKK" << "   " << r << endl;
		if (r == k) {
			
			res = v[k];
			return;
		}
		if (r < k) {
			quicksort1(v, r + 1, right);
		}
		else {
			quicksort1(v, left, r - 1);
		}
	}
	return;

}
void quicksort(vector<int> &v) {
	quicksort1(v, 0, v.size() - 1);
}
int main() {
	//cout << fibonacci2(8) << endl;
	//cout << fibonacci1(8) << endl;
	//vector<int> v;
	//mergesort(v);
	//for (int i = 0; i < v.size(); i++) {
	//	cout << v[i] << endl;
	//}
	vector<int> v = { 2,3,6,9,1,4,5 };
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << endl;
	cin >> k;

	//cout << partition(v,0,v.size()-1) << endl;
	quicksort(v);
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << res << endl;
}
```

## 网上参考
```c++
#include<stdio.h>
#include<stdlib.h>
/* 如何查找第k小的数，或者第k大的数*/
partition(int data[],size_t left ,size_t right)
{
     int i = left;
     int j = right;
     int p = (left + right) / 2;
     int pivot = data[p];
     while(i < j){
         for(; i < p && data[i] <= pivot;++i);
         if(i < p) {
             data[p] = data[i];
             p = i;
         }
         for(; j > p && data[j] >= pivot; --j);
         if( j > p){
             data[p] = data[j];
             p = j;
         }
     }
       data[p] = pivot;
       return p;

}
int quick_sort(int data[],size_t left, size_t right)
{
    if(left < right){
        int index = partition(data,left,right);
        if(index - left > 1 )  
            quick_sort(data,left, index-1);
        if(right - index > 1)
            quick_sort(data,index + 1, right);
    
    }

}
int findK(int data[], size_t left, size_t right, size_t k){
   if(left < right){
       int mid = partition(data,left, right);
       if(mid - left + 1 >= k)
           findK(data,left, mid, k );
       else 
           findK(data, mid + 1, right, k- (mid - left +1));
   }
   
}
int main()
{
    int data[] = {12,2,1 ,0 ,4,11,-1, 9 ,6};
    int len = sizeof(data)/sizeof(data[0]);
  //  quick_sort(data,0,len - 1);
    int i =0;
  /* 打印原始序列 */
    for( i = 0; i < len ; ++i)
    {
        printf(" %d ",data[i]);
    }
     findK(data,0,len - 1, 5);
    printf("x = %d\n", data[5] );
   /* 找到第k个大的数后，序列的变化为：---快排之前*/
    for( i = 0; i < len ; ++i)
    {
        printf(" %d ",data[i]);
    }
    printf("\n");
  /* 快排之后的序列*/
    quick_sort(data,0,len - 1);
    for( i = 0; i < len ; ++i)
    {
        printf(" %d ",data[i]);
    }
    printf("\n");

}
```