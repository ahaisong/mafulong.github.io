---
layout: post
category: 算法知识
title: 回溯法之八皇后问题
---



## 非递归实现
```c++
#include<stdio.h>
#include<iostream>
#include<string>
#include<algorithm>
#include<string.h>
#include<vector>
#include<unordered_map>
#include<stack>
#include<sstream>
#include<unordered_set>
using namespace std;
int x[9];
bool place(int k) {

	for (int i = 1; i < k; i++) {
		if (x[i] == x[k] || abs(x[i] - x[k]) == abs(i - k)) {
			//cout << "hhh    " << x[i] << " " << x[k] << " " << i << " " << k << endl;
			return false;

		}
	}
	return true;

}
int h;
void nqueens1(int n) {
	h = 0;
	int i, k;
	for (i = 1; i <= n; i++)
		x[i] = 0;
	k = 1;
	while (k >= 1)
	{
		x[k] = x[k] + 1;   //在下一列放置第k个皇后
		while (x[k] <= n && !place(k))
			x[k] = x[k] + 1;//搜索下一列
		if (x[k] <= n && k == n)//得到一个输出
		{
			//for(i=1;i<=n;i++)
			//    printf("%d ",x[i]);
			//printf("\n");
			cout << h++ << endl;
		
		}
		else if (x[k] <= n && k<n)
			k = k + 1;//放置下一个皇后
		else//x[k]>n;
		{
			x[k] = 0;//重置x[k],回溯
			k = k - 1;
		}
	}
}


int main() {
	nqueens1(8);
	return 0;
}
```

## 递归版
```c++
#include<iostream>
#include<math.h>
using namespace std;

int n = 8;
int total = 0;
int *c = new int(n);

bool is_ok(int row) {
	for (int j = 0; j != row; j++) {
		if (c[row] == c[j] || row - c[row] == j - c[j] || row + c[row] == j + c[j])
			return false;
	}
	return true;
}

void queen(int row) {
	if (row == n)
		total++;
	else
		for (int col = 0; col != n; col++) {
			c[row] = col;
			if (is_ok(row))
				queen(row + 1);
		}
}

int main() {
	queen(0);
	cout << total;
	return 1;
}
```