---
layout: post
category: 算法知识
tags: 算法复习
title: 算法复习
---
## gcd求最大公约数：
```c++
int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a%b);
}

int gcd(int a, int b) {
	while (b != 0) {
		int t = a%b;
		a = b;
		b = t;
	}
	return a;
}
```

## 进制转换
```c++
	int a, b;
	vector<int> v;
	cin >> a >> b;
	while (a != 0) {
		v.push_back(a%b);
		a = a / b;
	}
```

## fibonacci


## 插入排序

## 哈密顿回路、背包问题、任务分配问题

## 分治法

	归并排序、快速排序

## 减治法
	
	伪币问题、插入排序、DFS、BFS
	
	拓扑排序就是DFS算法结点出栈次序的反序

## 动态规划

	1. Multistage Graph problem（多段图问题）
	2. Floyd’s algorithms for all-pairs shortest paths
	3. Investment profit problem
	4. Longest path in DAG（最长路径问题)，拓扑顺序DP
	5. Edit distance
	6. Knapsack（背包问题)
	7. Constructing an optimal binary search tree
	    (最优二分检索树)  

## 贪心算法

背包问题，不能解决0/1背包问题
找零问题
Prim、Kruskal

## 分支限界

	边界选择: 实际产生的成本+估计的还要付出的最小成本
	任务分配、TCP找最短哈密顿回路、9幻方问题
	0/1背包问题：Ub=v+(W-w)(vi+1/wi+1)


## 回溯法

	8皇后问题、子集和数问题、m着色方案

8皇后非递归算法

	NQueens1(int n)
	{   int k, n; extern int x[n];  k=0; x[k]= -1;
	     while(k>=0)
	     {   x[k]=x[k]+1; 
	          while((x[k]<n) && (!Place(k)) x[k]=x[k]+1;
	          if(x[k]<n)  
	          {   if(k<n-1) {   k=k+1;  x[k]=-1;  }
	              else  printf(x[0:n-1]); 	
	          }
	          else k=k-1;
	       }
	}

8皇后递归算法

	NQueens2(int k)
	{   extern int x[n];  
	     x[k]=-1;
	     while(1)
	     {   x[k]=x[k]+1; 
	          while((x[k]<n)&&(!Place(k)) x[k]=x[k]+1;
	          if(x[k]<n)	
	          {   if(k<n-1) NQueens2(k+1); 
	               else printf(x[0:n-1]); 
	          }
	          else return;
	      }
	}

子集和数递归算法

	Subset1(float s, float r, int k)
	{   extern float w[n]; extern int x[n];
	     x[k]=1;    //
	     if(s+w[k]==M)  printf(x[1:k]);   //测试是否是解状态
	     else if( (s+r)>=M) && ((s+w[k]+w[k+1]<=M)) //不是解的话，则测试x[k]=1是否满足规范函数 ,如果满足，则继续向下
	                 Subset1(s+w[k], r-w[k], k+1); 
	     if((s+r-w[k]>=M)&&((s+w[k+1])<=M)) //测试x[k]=0是否满足规函数，如果满足，则继续向下
	{   x[k]=0;  
	          Subset1(s, r-w[k], k+1);  
	     }
	} 

子集和数非递归算法

	Subset2(int n)
	{   float s=0, r=sum of w[1:n-1];   x[1:n]=2;  k=1;
	     while(k>0)
	     {   x[k]=x[k]-1;
	         if(s+w[k]==M) printf(x[1:k]); //先测试1分支是否是解
	          else if((s+r>=M)&& (s+w[k]+w[k+1]<=M)) //若还不是解，则测试是否可能会导致解,如果可能，则继续向下
	                 {   s=s+w[k];   r=r-w[k];   k++;  }
	
	          if(x[k]==0)  //0分支
	          {   if( (s+r-w[k]>=M)&&(s+w[k+1]<=M))  //如果可能会导致解，则继续向下
	                      {  r=r-w[k];  k++; continue; }
	               else {   k=k-1;   s=s-x[k]*w[k];  r=r+w[k];  x[k]=2;  continue;}勤//0       分支也不能向下走了，就回溯,  恢复s,r 等的值
	          }
	}


## 火车进站入站问题
编号为1,2,3,4 的四列火车通过一个栈式的列车调度站，可能得到的调度结果有哪些？如果
有n 列火车通过调度站，请设计一个算法，输出所有可能的调度结果。 

解题思路：栈具有先进后出、后进先出的特点，因此，任何一个调度结果应该是1 ，2 ，3 ，4
全排列中的一个元素。由于进栈的顺序是由小到大的，所以出栈序列应该满足以下条件：对于
序列中的任何一个数其后面所有比它小的数应该是倒序的，例如4321 是一个有效的出栈序列，
1423不是一个有效的出栈结果（4 后面比它小的两个数 2 ，3 不是倒序）。据此，本题可以通过
算法产生n 个数的全排列，然后将满足出栈规则的序列输出。 