---
layout: post
category: 算法知识
title: 动态规划之完全背包硬币找零问题
---

# 动态规划之完全背包硬币找零问题

## 解法1

### 完全背包
```
f[i][j]=max(f[i－1][j-k*weight[i]+k*value[i])，其中0<=k<=j/weight[i]  
```
可以理解为：j为背包可以容纳的重量，有i种物品时，向背包里添加第i种物品，第i种物品可以添加的个数范围是 0<=k<=j/weight[i]

### 硬币找零

    f[i][j]=min(f[i－1][j-k*value[i]+k)，其中0<=k<=j/value[i]  

可以理解为：j为需要找零多少元，有i种硬币，找零时选取第i种硬币，第i种硬币可以选取的枚数是 0<=k<=j/value[i]

**注意**：
其实上面这种解法看来貌似没什么问题，但是上面的递归公式有冗余计算，例如下面两个式子:

    f[i][j]=max{ f[i−1,j− value(i)∗k] + value(i)∗k }, 0≤ k ≤ x/need(i)
    f[i][j−value(i)]=max{ f[i−1][j− value(i)∗k] + value(i)∗k }, 1≤ k ≤ x/value(i)

在计算上面第一个式子时，又把第二个式子中大部分重新计算了一遍。 所以解法1并不高效，一般不会用。

## 解法2

### 完全背包

    f (j) = max{  f(j - weight[i]) ＋ value[i],  i = 0......N  ｝

可以理解为：j为背包可以容纳的重量，有N种物品，对于每种物品假设至少包含一个，至于到底包含多少个我们并不关心。

### 硬币找零

    f (j) = min{  f(j - coin[i]) ＋ 1,  i = 0......N  ｝  

可以理解为：j为需要找零多少元，有N种硬币，对于每种硬币，我们可以依次假设f(i)中至少包含一个coin[j] (j=0, 1......N) ，然后得到所需的最少硬币是f(j- coin[i]) ＋ 1，最后再从这N次假设中选出最小的就是f(i)。

有人可能会有疑问，为什么只是假设存在一块硬币coin[j]，存在k块硬币难道不用考虑吗？假如f(i)真的包含多个coin[j]，我们只取一个coin[j]，那么剩下的几个coin[j]的最优组合肯定已经包含在 f(i - coin[j]) 里面了，我们根本不用关心它们。

```java
#include<iostream>  
using namespace std;  
//money需要找零的钱  
//coin可用的硬币  
//硬币种类  
void FindMin(int money,int *coin, int n)  
{  
    int *f =new int[money+1]();//存储1...money找零最少需要的硬币的个数  
    int *coinValue=new int[money+1]();//最后加入的硬币，方便后面输出是哪几个硬币  
    coinNum[0]=0;  
  
    for(int i=1; i<=money; i++)  
    {  
        int minNum=i;//表示i个1元硬币正好找零i元，这是一种找零的组合，并不是所有组合里面最少的，下面寻找最少值
        int curMoney=0;//这次找零，在原来的基础上需要的硬币  
        for (int j=0;j<n;j++)  
        {  
            if (i>=coin[j])//找零的钱大于这个硬币的面值  
            {  
                if( f[i-coin[j]]+1<=minNum) {
                    //在更新时，需要判断i-coin[j]是否能找的开，如果找不开，就不需要更新
                    if (i-coin[j] == 0 || coinValue[i-coin[j]]!=0 )  
                    {  
                        minNum = f[i-coin[j]] + 1;//更新  
                       curMoney = coin[j];//更新  
                    }  
                }
            }  
        }  
        f[i]=minNum;  
        coinValue[i]=curMoney;  
    }  
  
    //输出结果  
    if(coinValue[money]==0)  
        cout<<"找不开零钱"<<endl;  
    else  
    {  
        cout<<"需要最少硬币个数为："<<f[money]<<endl;  
        cout<<"硬币分别为:";  
        while(money>0)  
        {  
            cout<<coinValue[money]<<",";  
            money-=coinValue[money];  
        }  
    }  
    delete []f;  
    delete []coinValue;  
}  
int main()  
{  
    int Money=18;  
    int coin[]={1,2,5,9,10};  
    FindMin(Money,coin,5);  
  
}  
```

## 解法3

### 背包

    f[ i ] [ j ] = max( f[i－1][j],  f[ i ][ j- weight[i] ] + value[i] )   ，注意后面是f[i, j-weight[i]]，i 没有减1  

可以理解为：j为背包可以容纳的重量，有i种物品时，对于第i种物品，要么取或者不取，至于取多少个我们并不关心。

### 找零

    f[i][j]=min( f[i－1][ j ], f [i ] [ j - value[i] ] + 1)   ，注意后面是f[i, j-value[i]]，i 没有减1  

可以理解为：j为需要找零多少元，有i种硬币，找零时对于第i种硬币，我们只考虑取或者不取，至于取多少个我们并不关心！

**两种边界情况说明一下**：

（1）f[0][j]=Integer.MAXVALUE ，因为 对金额为 j 的钱找零，但是可以的硬币面值种类为0，这显然是无法做到的。其实这是一个”未定义“的状态。它之所以初始为Integer.MAXVALUE

（2）f[i][0]=0，因为，对金额为0的钱找零，可用来找零的硬币种类有 i 种，金额为0怎么找啊，故设置为0。

```java
/* 
 *  
 * @param coinsValues 可用来找零的硬币 coinsValues.length是硬币的种类 
 * @param n 待找的零钱 
 * @return 最少硬币数目 
 */  
public static int charge(int[] coinsValues, int n){  
    int[][] c = new int[coinsValues.length + 1][n + 1];  
      
    // 初始化边界条件  
    for(int i = 0; i <= coinsValues.length; i++) ｛  
        c[i][0] = 0;  
    ｝  
    for(int i = 0; i <= n; i++)｛  
        c[0][i] = Integer.MAX_VALUE;  
    ｝  
      
    for(int i = 1; i<=coinsValues.length; i++){ //i表示参加找零的硬币的种类1~i种硬币  
        for(int j = 1; j <= n; j++){//j表示需要找零的钱数  
            if(j < coinsValues[i-1]){  
                c[i][j] = c[i - 1][j];  
                continue;  
            }  
              
            //每个问题的选择数目---选其中较小的  
            if(c[i - 1][j] < (c[i][j - coinsValues[i-1]] +1)) {  
                c[i][j] = c[i - 1][j];  
            } else {  
                c[i][j] = c[i][j - coinsValues[i-1]] +1;  
            }  
        }  
    }  
  
    return c[coinsValues.length][n];  
}  
```