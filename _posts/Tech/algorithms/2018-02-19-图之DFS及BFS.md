---
layout: post
category: 算法知识
title: 图之DFS及BFS
---


## 图存储：

声明为共有变量

1. e[n][n]存储边花费，n个点

2. vector<int> e[n]存储边花费，n个点

## 其他变量

1. vis[n]，存储是否识别，dfs、bfs、dijstra算法中需要

2. d[n]距离算法中需要

3. c[n][n]存储第二花费，最短路径第二花费最小问题

4. num[n]存储最短路径数量，最短路径个数问题

5. weight[n]存储各点权重，w[n]存储到各点的权和，最短路径最大权问题

## DFS:

```c++
dfs(u) {
  vis[u] = true;
  for(从u除法道能到达的所有顶点v)
    if(vis[v] == false)
      dfs(v);
}
dfsTrave(G) {
  for(G的所有结点u)
    if(vis[u] == false)
      dfs(u);
}
```

```c++
//邻接矩阵
void dfs(int u, int depth) {
  vis[u] = true;
  for(int v = 0; v < n; v++) {
    if(vis[v] == false && G[u][v] != INF)
      dfs(v, depth + 1);
  }
}

void dfsTrave() {
  for(int u = 0; u < n; u++)
  	if(vis[u] == false)
    	dfs(u, 1);
}
```

```c++
//邻接表
void dfs(int u, int depth) {
  vis[u] = true;
  for(int u = 0; u < arr[u].size(); u++)
    dfs(v, depth + 1);
}

void dfsTrave() {
  for(int u = 0; u < n; u++) {
    if(vis[u] == false)
      dfs(u, 1);
  }
}
```

## BFS

```c++
bfs(u) {
  queue q;
  将u入队
  inq[u] = true;
  while(q非空) {
    for(从u除法道可到达的所有定点v) {
      if(inq[v] == false)
        将v入队
        inq[v] = true;
    }
  }
}
bfsTrave(G) {
  for(G的所有顶点u) {
    if(inq[u] == false)
      bfs(u);
  }
}
```


```c++
void bfs(int u) {
  queue<int> q;
  q.push(u);
  inq[u] = true;
  while(!q.empty()) {
    int u = q.front();
    q.pop();
    for(int v = 0; v < n; v++) {
      if(inq[u] == false && G[u][v] != INF) {
        q.push(v);
        inq[v] = true;
      }
    }
  }
}
/*邻接表：
for(int i = 0; i < arr[u].size(); i++) {
  int v= arr[u][i];
  if(inq[u] == false) {
    q.push(v);
    inq[v] = true;
  }
}
*/
```

```c++
void bfsTrave() {
  for(int u = 0; u < n; u++) {
    if(inq[u] == false)
      bfs(q);
  }
}
```
