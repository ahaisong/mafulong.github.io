---
layout: post
category: 算法知识
title: 堆排序
---
## 时间复杂度
建堆：O(n); 更新堆： O(nlogn)

## 由于是完全二叉树, 故有:
```
PARENT(i)
  return i / 2
LEFT(i)
  return 2 * i
RIGHT(i)
  2 * i + 1
```

## 建堆
### 对非叶子节点形成堆，伪代码：
```
//
MAX-HEAPIFY(A, i)

l = LIFT(i)
r = RIGHT(i)
if l <= A.heapsize and A[l] > A[i]
  largest = l
else largest = i
if r <= A.heapsize and A[r] > A[largest]
  largest = r
if largest != i
  exchage A[i] with A[largest]
  MAX-HEAPIFY(A, largest)
```
  
### Build Heap 

以最大堆为例，伪代码：
```

BUILD-MAX-HEAP(A)：

A.heap-size = A.length
for A.length / 2 downto 1
  MAX-HEAPIFY(A, i)
```

## 堆排序
以最大堆为例，伪代码：
```

HEAPSORT(A) ：
BUILD-MAX-HEAP(A)

for i = A.length downto 2
  exchange A[1] with A[i]
  A.heap-size = A.heap-size - 1
  MAX-HEAPIFY(A, 1)
```
 
## c++代码
```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

void adjust(int arr[], int len, int index)
{
    int left = 2*index + 1;
    int right = 2*index + 2;
    int maxIdx = index;
    if(left<len && arr[left] > arr[maxIdx]) maxIdx = left;
    if(right<len && arr[right] > arr[maxIdx]) maxIdx = right;  // maxIdx是3个数中最大数的下标
    if(maxIdx != index)                 // 如果maxIdx的值有更新
    {
        swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);       // 递归调整其他不满足堆性质的部分
    }

}
void heapSort(int arr[], int size)
{
    for(int i=size/2 - 1; i >= 0; i--)  // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)
    {
        adjust(arr, size, i);
    }
    for(int i = size - 1; i >= 1; i--)
    {
        swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
        adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序
    }
}

int main()
{
    int array[8] = {8, 1, 14, 3, 21, 5, 7, 10};
    heapSort(array, 8);
    for(auto it: array)
    {
        cout<<it<<endl;
    }
    return 0;
}
```