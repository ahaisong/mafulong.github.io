---
layout: post
category: 算法知识
title: 二叉树之创建二叉树
---

## 创建二叉树
只有先序、后序、层序可以用来创建二叉树（且要添加虚空节点），中序是不可以的。

原因很简单，因为即使添加了虚空节点，中序序列仍然不可以唯一确定一棵二叉树。

## 树节点
```
struct t{
    int value;
    t *left,*right;
    t(){

    }
    t(int v):value(v),left(NULL),right(NULL){

    }
}
```

## 根据前序构建二叉树
```c++

    //先序遍历数组s创建二叉树，size为数组大小，index为数组索引
    //后序遍历创建二叉树可由index从大到小递减得到
    t* createtree(int *s, int size, int &index) {
        t *root = NULL;
        if (index < size&&s[index] != 0) {
            root = new t;
            root->value = s[index];
            cout << "building " << s[index] << endl;
            root->left=createtree(s, size, ++index);
            root->right=createtree(s, size, ++index);
            return root;
        }
        else {
            cout << "invaild" << endl;
            return root;
        }
    }
```

## 根据后序构建二叉树
```c++

    //先序遍历数组s创建二叉树，size为数组大小，index为数组索引
    //后序遍历创建二叉树可由index从大到小递减得到
    t* createtree(int *s, int size, int &index) {
        t *root = NULL;
        if (index < size&&s[index] != 0) {
            root = new t;
            root->value = s[index];
            cout << "building " << s[index] << endl;
            root->right=createtree(s, size, --index);
            root->left=createtree(s, size, --index)            
            return root;
        }
        else {
            cout << "invaild" << endl;
            return root;
        }
    }

    
```

## 根据层次遍历构建二叉树
```c++

    //由层次遍历创建树
    t* createtreebfs(int *s, int size, int index) {
        t *root = NULL;
        if (index < size&&s[index] != 0) {
            root = new t;
            root->value = s[index];
            root->left = createtreebfs(s, size, 2 * index);
            root->right = createtreebfs(s, size, 2 * index + 1);
        }
        return root;
    }
```
