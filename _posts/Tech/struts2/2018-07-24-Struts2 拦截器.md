---
layout: post
category: struts2
title: Struts2 拦截器
---

## Struts2 拦截器

拦截器在概念上与servlet过滤器或JDK代理类相同。拦截器允许横切功能，把action以及框架分开实现。你可以使用拦截器实现以下操作：

- 在调用action之前提供预处理逻辑。
- 在调用action后提供后处理逻辑。
- 捕获异常，以便可以执行备用处理。

Struts2框架中提供的许多功能都是使用拦截器实现的，包括异常处理，文件上传，生命周期回调和验证等。事实上，由于Struts2将其大部分功能基于拦截器，因此不太可能为每个action分配7个或8个拦截器。

## 如何使用拦截器？
让我们看看如何在我们的“Hello World”程序中使用一个已经存在的拦截器。我们将首先使用timer拦截器，目的是测量执行action方法所需的时间。

```xml
参照下面修改struts.xml文件给它添加拦截器：
 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
   "http://struts.apache.org/dtds/struts-2.0.dtd">
<struts>
   <constant name="struts.devMode" value="true" />
   <package name="helloworld" extends="struts-default">
      <action name="hello" 
         class="cn.w3cschool.struts2.HelloWorldAction"
         method="execute">
         <interceptor-ref name="timer" />
         <result name="success">/HelloWorld.jsp</result>
      </action>
   </package>
</struts>
```

可以在日志中看到消息

## 创建自定义拦截器
在你的应用程序中使用自定义拦截器是提供跨切割应用程序功能的简洁方式。创建自定义拦截器很容易，需要扩展的是以下Interceptor接口：

```java
public interface Interceptor extends Serializable{
   void destroy();
   void init();
   String intercept(ActionInvocation invocation)
   throws Exception;
}
```

正如name所指出的，init()方法提供了一种初始化拦截器的方法，而destroy()方法为拦截器清理提供了一个工具。与action不同，拦截器在请求之间重复使用，需要线程安全，特别是intercept()方法。

ActionInvocation对象可访问运行时的环境。它允许访问action本身以及方法来调用action，并确定action是否已被调用。

如果你不需要初始化或清理代码，可以扩展AbstractInterceptor类，以实现init()和destroy()的默认的无操作指令。

### 创建拦截器类
我们接下来在Java Resources>src文件夹中创建以下MyInterceptor.java文件：
```java
package cn.w3cschool.struts2;

import java.util.*;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;

public class MyInterceptor extends AbstractInterceptor {

   public String intercept(ActionInvocation invocation)throws Exception{

      /* let us do some pre-processing */
      String output = "Pre-Processing"; 
      System.out.println(output);

      /* let us call action or next interceptor */
      String result = invocation.invoke();

      /* let us do some post-processing */
      output = "Post-Processing"; 
      System.out.println(output);

      return result;
   }
}
```

你可以发现，实际中action将通过拦截器使用invocation.invoke()调用执行，所以你可以根据你的需求做一些预处理和一些后处理。

框架本身通过第一次调用ActionInvocation对象的invoke()来启动进程。每次调用invoke()时，ActionInvocation都会查询其状态，并执行下一个拦截器。当所有配置的拦截器都被调用时，invoke()将使得action本身被执行。以下图表通过请求流显示了所说的概念：

![](https://7n.w3cschool.cn/attachments/tuploads/struts_2/actioninvocation.jpg)

## 配置文件
现在我们需要注册新的拦截器，然后调用它，因为我们在前面的例子中调用的是默认拦截器。要注册一个新的拦截器，把<interceptors> ... </ interceptors>标签直接放置在<package>标签下的struts.xml文件中即可。对于默认拦截器，你可以跳过此步骤，就像我们前面的示例中所做的那样。但现在让我们使用以下方法注册新的： 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
    "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
   <constant name="struts.devMode" value="true" />
   <package name="helloworld" extends="struts-default">

      <interceptors>
         <interceptor name="myinterceptor"
            class="cn.w3cschool.struts2.MyInterceptor" />
      </interceptors>

      <action name="hello" 
         class="cn.w3cschool.struts2.HelloWorldAction" 
         method="execute">
         <interceptor-ref name="params"/>
         <interceptor-ref name="myinterceptor" />
         <result name="success">/HelloWorld.jsp</result>
      </action>

   </package>
</struts>
```

web.xml文件需要在WebContent下的WEB-INF文件夹下创建，如下所示：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns="http://java.sun.com/xml/ns/javaee" 
   xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
   id="WebApp_ID" version="3.0">
   
   <display-name>Struts 2</display-name>
   <welcome-file-list>
      <welcome-file>index.jsp</welcome-file>
   </welcome-file-list>
   <filter>
      <filter-name>struts2</filter-name>
      <filter-class>
         org.apache.struts2.dispatcher.FilterDispatcher
      </filter-class>
   </filter>

   <filter-mapping>
      <filter-name>struts2</filter-name>
      <url-pattern>/*</url-pattern>
   </filter-mapping>
</web-app>
```

## 拦截器堆栈
你可以想象，为每个action配置的多个拦截器将很快变得极其难以管理。为此，拦截器使用拦截器堆栈进行管理。这里是直接从struts-default.xml文件展示的一个例子： 

```xml
<interceptor-stack name="basicStack">
   <interceptor-ref name="exception"/>
   <interceptor-ref name="servlet-config"/>
   <interceptor-ref name="prepare"/>
   <interceptor-ref name="checkbox"/>
   <interceptor-ref name="params"/>
   <interceptor-ref name="conversionError"/>
</interceptor-stack>

```
上面的堆栈称为basicStack，可以如下所述在你的配置中使用，此配置节点放置在<package ... />节点下。

<interceptor-ref ... />标签引用的是在当前拦截器堆栈之前配置的拦截器或拦截器堆栈。因此非常重要的是在配置初始拦截器和拦截器堆栈时，确保name在所有拦截器和拦截器堆栈配置中是唯一的。

我们已经学习了如何将拦截器应用到action中，而拦截器堆栈的应用也是类似的。事实上，使用的标签也是一样的：


```xml
<action name="hello" class="com.tutorialspoint.struts2.MyAction">
   <interceptor-ref name="basicStack"/>
   <result>view.jsp</result>
</action
```

上述的“basicStack”注册将完整注册hello action的所使用的六个拦截器。要注意的是，拦截器按照它们被配置的顺序执行。例如，在上面的例子中，exception将首先执行，第二个将是servlet-config等。

